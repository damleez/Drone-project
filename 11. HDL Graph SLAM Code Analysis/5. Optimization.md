## 1. Timing Optimization

- 이전에 전달된 모든 센서 정보를 최적화 전에 버퍼 큐에 넣어야 하는 이유
  - hdl이 백엔드 최적화 메커니즘을 사용하여 정기적으로 호출을 최적화하기 때문
- 따라서 각 최적화 간격 동안 서로 다른 센서가 독립적으로 데이터와 캐시를 수집해야함 
- 또한,최적화 중에 최신 키프레임 타임스탬프에 따라 다른 모든 센서 데이터 정보를 일치시키고 해당 가장자리 제약 조건을 추가하고 오래된 센서 데이터를 제거

- 그 중 각 최적화 과정에서 폐루프 검출을 수행하고 가능한 모든 폐루프 조건을 찾아 폐루프 제약 조건을 추가
- 닫힌 루프가 처리되면 새로 추가된 키프레임이 기록 키프레임으로 저장되고 새 키프레임 대기열이 지워져 새로 추가된 키프레임이 기록 키프레임으로 닫힌 루프 제약을 수행할 기회가 한 번만 있도록 함

#### - 총 두가지의 작업을 수행
1) 폐루프 감지 - 폐루프 를 감지하여 최적화 전에 물론 확률 맵에 추가
2) 단순화된 키프레임 생성
- 프레임 섹션에서 소개한 간소화된 버전의 키프레임(KeyFrameSnapshot)을 기억하십니까? 
- 맵 스티칭을 위해 KeyFrame 클래스에서 포즈(물론 최적화된 포즈)와 포인트 클라우드를 가져와 최적화된 포즈로 맵을 얻음

## 2. keyframe snapshot

![image](https://user-images.githubusercontent.com/108650199/200778219-1bc27dcc-fc86-4183-97ca-92f83146cb33.png)

- KeyFrameSnapshot 클래스는 KeyFrame 클래스의 단순화된 버전으로 이해할 수 있으며, 포즈와 포인트 클라우드 정보만 포함하고 있으며 맵에는 각 프레임의 포즈와 원래 포인트 클라우드만 있으면 되므로 맵을 접합할 때 사용

## 3. [Information matrix](https://zhuanlan.zhihu.com/p/381805871)

![image](https://user-images.githubusercontent.com/108650199/200779024-be8d8f02-f82d-4de3-8267-8a2cdf172d90.png)

- 먼저, 상수 정보 행렬을 사용할지 여부를 판단
- 일반적으로 단위 행렬 1/0.5=50을 포즈로, 1/0.1=10을 각도로 사용하여 각도보다 포즈를 더 많이 믿음

## 4. GPS 좌표 변환

![image](https://user-images.githubusercontent.com/108650199/200779747-8b6f9fa6-985e-439d-83d0-402772393c4b.png)

- GPS 좌표 변환: 주로 GPS 지구 좌표계 -> 측지 좌표계(UTM) -> UTM 좌표계로 변환한 다음 로컬 좌표 로 변환 
- 여기에서는 gps의 X 및 Y 정보만 사용하고 z 방향의 정보는 사용하지 않음
  - 주요 원인은 정확하지 않기 때문
